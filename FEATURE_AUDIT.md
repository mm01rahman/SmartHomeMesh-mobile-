# ESP v2.0 Mobile-App Feature Audit

The table below checks the Flutter client against the 16 requested ESP v2.0 capabilities.

| # | Feature | Status in mobile app | Evidence |
|---|---------|---------------------|----------|
| 1 | Global MQTT online mode | **Partial.** MQTT transport exists with cmd/status/ack topics, but it targets an insecure public broker on port 1883 and has no TLS parameters. | MQTT client setup and subscriptions use port 1883 and only status/ack topics, without TLS options.【F:app/lib/data/datasources/mqtt_device_control_service.dart†L17-L86】 |
| 2 | Local STA HTTP mode | **Present.** HTTP control posts the same `dev`/`st` command payload to a configurable base IP (default ESP AP) and can poll `/status`. | HTTP device control sends commands and polls state over REST endpoints.【F:app/lib/data/datasources/http_device_control_service.dart†L7-L42】 |
| 3 | AP mode for provisioning + fallback | **Partial.** The connectivity layer detects ESP-like SSIDs and switches to an AP-local HTTP transport with a default IP, but there is no dedicated provisioning UI flow. | AP detection uses Wi‑Fi SSID heuristics and swaps transport to an AP HTTP client.【F:app/lib/features/connectivity/application/connectivity_notifier.dart†L30-L120】 |
| 4 | Smart first-boot provisioning system | **Missing.** UI data comes from hard-coded sample nodes/rooms/devices; no screens or flows collect Wi‑Fi credentials or drive first-boot setup. | Dashboard/rooms/devices screens render static mock data rather than provisioning or live discovery flows.【F:app/lib/features/dashboard/presentation/dashboard_screen.dart†L11-L140】【F:app/lib/features/rooms/presentation/rooms_screen.dart†L13-L30】【F:app/lib/features/devices/presentation/device_list_screen.dart†L17-L71】 |
| 5 | Automatic mode switching | **Present.** `deriveMode` maps connectivity + broker reachability to cloud/local/AP/offline modes and updates the notifier state. | Mode derivation and notifier updates respond to connectivity and MQTT reachability checks.【F:app/lib/features/connectivity/application/connectivity_notifier.dart†L24-L120】 |
| 6 | AP retry stability fix | **Missing.** There is no state machine to re-enable AP after failed STA/MQTT attempts; the notifier only maps instantaneous connectivity without retry policies. | Connectivity logic is limited to single-step mode derivation without retry/backoff handling.【F:app/lib/features/connectivity/application/connectivity_notifier.dart†L45-L114】 |
| 7 | WiFi/AP policy logic (3-stage) | **Partial.** Modes for cloud, LAN-only, AP, and offline exist, but there is no logic to disable AP after first STA join or enforce the three-stage policy described. | Modes are derived purely from connectivity signals; no policy state is tracked beyond the four static modes.【F:app/lib/features/connectivity/application/connectivity_notifier.dart†L102-L120】 |
| 8 | ESP-NOW mesh for offline control | **Missing.** Only MQTT and HTTP transports are available; no ESP-NOW mesh transport or bridging is implemented. | Transport resolver selects between MQTT and HTTP only, with no mesh channel.【F:app/lib/features/connectivity/application/connectivity_notifier.dart†L78-L86】 |
| 9 | Multi-device per node support | **Present.** Models allow multiple logical devices per node with typed metadata and unified IDs. | Node/device models store lists of devices per node and compute `node:device` identifiers.【F:app/lib/data/models/node_model.dart†L4-L40】【F:app/lib/data/models/device_model.dart†L6-L78】 |
| 10 | Dynamic device discovery (JOIN packet) | **Partial.** Node repository can parse JOIN payloads, but MQTT never subscribes to JOIN topics so discovery is unhooked. | JOIN ingestion exists in the repository, while MQTT subscribes only to status/ack topics.【F:app/lib/data/repositories/node_repository.dart†L30-L44】【F:app/lib/data/datasources/mqtt_device_control_service.dart†L46-L79】 |
| 11 | Periodic device state sync (STATUS packet) | **Partial.** MQTT decodes STATUS payloads and repository can apply them, but the two pieces are not wired together in the app startup flow. | STATUS parsing is present in MQTT service; repository has an `ingestStatus` handler but no subscription hookup is shown.【F:app/lib/data/datasources/mqtt_device_control_service.dart†L46-L79】【F:app/lib/data/repositories/node_repository.dart†L46-L75】 |
| 12 | Unified command format `node:device` | **Present.** Both MQTT and HTTP command payloads use the `dev` field containing the `node:device` identifier. | MQTT and HTTP send commands with full device IDs in the `dev` field.【F:app/lib/data/datasources/mqtt_device_control_service.dart†L82-L86】【F:app/lib/data/datasources/http_device_control_service.dart†L17-L21】 |
| 13 | Full local HTTP REST control | **Present.** Local HTTP service mirrors MQTT commands and can poll `/status`, enabling AP or LAN-only control. | REST endpoints `/cmd` and `/status` are used for control/state retrieval.【F:app/lib/data/datasources/http_device_control_service.dart†L17-L39】 |
| 14 | Persistent NVS storage | **Partial (client-side only).** The Flutter app persists nodes/rooms/scenes via Hive, but there is no device-side NVS management reflected. | Hive-backed cache initialization for nodes/rooms/scenes is the only persistence present in the app.【F:app/lib/data/datasources/local_cache_data_source.dart†L4-L15】 |
| 15 | Flutter app auto-detects device mode | **Present.** The connectivity notifier bootstraps at app start and exposes the current mode to UI components such as the status banner. | App startup watches the connectivity notifier; the banner renders the derived mode and description.【F:app/lib/main.dart†L9-L28】【F:app/lib/common/widgets/connectivity_status_banner.dart†L6-L42】 |
| 16 | Backend-ready scenes & automations | **Partial.** Scene models and sample quick actions exist, but they operate on hard-coded data and do not dispatch commands to devices or MQTT/HTTP services. | Scenes are static and their buttons lack command dispatch logic, indicating no backend/mesh integration yet.【F:app/lib/features/dashboard/presentation/dashboard_screen.dart†L33-L84】 |

## Overall

The current Flutter client covers basic MQTT/HTTP command paths, mode detection, and multi-device modeling, but provisioning, mesh (ESP-NOW), robust AP/STA policies, and live JOIN/STATUS wiring remain incomplete. Many UI surfaces still use mock data rather than live discovery or backend state, leaving several ESP v2.0 requirements unmet.
